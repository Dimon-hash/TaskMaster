<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Сделать фото</title>
  <style>
    :root{color-scheme:dark}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0b0f14;color:#fff}
    .wrap{padding:16px;display:flex;flex-direction:column;gap:14px;align-items:center;max-width:520px;margin:0 auto}
    video#v{width:100%;max-width:480px;border-radius:16px;background:#000}
    canvas#c{display:none}

    .title{font-size:16px;opacity:.95;text-align:center}
    .pill{font-variant-numeric:tabular-nums;font-weight:700;background:#0f1620;border:1px solid #1d2732;border-radius:999px;padding:8px 12px}
    .bar{width:100%;max-width:420px;height:10px;background:#0f1620;border-radius:999px;overflow:hidden;border:1px solid #1d2732}
    .bar>i{display:block;height:100%;width:0%}
    .status{font-size:14px;opacity:.85;text-align:center}
    .err{color:#ff6b6b}
    .muted{opacity:.8}
    .row{display:flex;gap:8px}
    .btn{appearance:none;border:1px solid #1d2732;background:#0f1620;color:#fff;border-radius:10px;padding:10px 14px;font-size:14px}
    .btn:active{transform:scale(0.99)}
    .hidden{display:none}
  </style>
</head>
<body>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<div class="wrap">
  <div class="title">Подготовка…</div>
  <video id="v" playsinline autoplay muted></video>
  <canvas id="c"></canvas>

  <div class="pill">—</div>
  <div class="bar"><i></i></div>
  <div class="status muted">Дайте доступ к камере (системный запрос).</div>

  <div class="row">
    <button id="stopBtn" class="btn hidden">⏹ Стоп</button>
  </div>
</div>

<script>
(() => {
  const tg = window.Telegram?.WebApp;
  tg?.expand?.(); tg?.ready?.();

  let stream = null, stopRequested = false;
  const v = document.getElementById('v');
  const c = document.getElementById('c');
  const title = document.querySelector('.title');
  const pill  = document.querySelector('.pill');
  const fill  = document.querySelector('.bar > i');
  const status= document.querySelector('.status');
  const stopBtn = document.getElementById('stopBtn');

  // ---- параметры из query ----
  const qs = new URLSearchParams(location.search);
  const mode      = (qs.get('mode') || 'single').toLowerCase();  // single | workout
  const shots     = Math.max(1, Math.min(10, parseInt(qs.get('shots') || '1', 10)));
  const windowSec = Math.max(20, Math.min(3600, parseInt(qs.get('window') || '60', 10)));

  // НОВОЕ: случайная задержка для одного снимка
  const delayMin  = Math.max(1, parseInt(qs.get('delay_min') || '10', 10));
  const delayMax  = Math.max(delayMin, parseInt(qs.get('delay_max') || '30', 10));

  const inTelegram = !!(tg && (tg.platform || tg.initDataUnsafe?.user || (tg.initData && tg.initData.length)));
  const dev = qs.get('dev') === '1' || !inTelegram;

  // ---- helpers ----
  function setStatus(text, isErr=false){ status.textContent = text; status.className = 'status' + (isErr ? ' err' : ' muted'); }
  function progress(pct){ fill.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
  function stopStream(){ try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch(_){} stream=null; }
  function endAndClose(delay=300){ stopStream(); setTimeout(()=>tg?.close?.(), delay); }
  const sleep = ms => new Promise(r=>setTimeout(r, ms));
  const rndInt = (a,b)=> a + Math.floor(Math.random()*(b-a+1));

  stopBtn.addEventListener('click', () => {
    stopRequested = true;
    setStatus('Сеанс остановлен пользователем.');
    endAndClose(400);
  });

  function canvasToBlob(canvas, type='image/jpeg', q=0.85){
    return new Promise(res=>{
      if (canvas.toBlob) return canvas.toBlob(b=>res(b), type, q);
      const dataURL = canvas.toDataURL(type, q);
      const bin = atob(dataURL.split(',')[1]);
      const bytes = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
      res(new Blob([bytes], {type}));
    });
  }

  async function captureAndSend(kind){
    const vw=v.videoWidth||720, vh=v.videoHeight||1280;
    const w=Math.min(1280,vw), h=Math.round(w*(vh/vw));
    c.width=w; c.height=h;
    const ctx = c.getContext('2d', {willReadFrequently:true});
    ctx.drawImage(v,0,0,w,h);

    const blob = await canvasToBlob(c,'image/jpeg',0.85);
    const form = new FormData();
    form.append('photo', blob, `shot_${Date.now()}.jpg`);
    form.append('initData', inTelegram ? (tg.initData || '') : '');

    const uploadUrl = new URL('/upload' + (dev ? '?dev=1' : ''), location.origin).toString();
    const r = await fetch(uploadUrl, { method:'POST', body:form });
    if (!r.ok){
      const t = await r.text().catch(()=>String(r.status));
      throw new Error(`Upload failed: ${r.status} ${t}`);
    }
    const data = await r.json();
    if (!data?.token) throw new Error('No token from server');

    if (inTelegram){
      // НОВОЕ: для одиночного фото шлём single_photo_uploaded
      const payload = {
        type: (kind === 'single' ? 'single_photo_uploaded' : 'set_photo_uploaded'),
        token: data.token,
        auto: true
      };
      tg.sendData(JSON.stringify(payload));
    } else {
      console.log('DEV token:', data.token);
    }
  }

  function randomSchedule(n, totalSec){
    const minGap = 5; // защитный интервал
    const times = Array.from({length:n}, () => Math.random()).sort((a,b)=>a-b);
    return times.map(t => Math.floor(minGap + t*(Math.max(totalSec-2*minGap, minGap))));
  }

  async function ensureCamera(){
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'user' } }, audio:false });
    } catch {
      stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
    }
    v.srcObject = stream;
    await new Promise(res=>{
      if (v.readyState >= 1) return res();
      v.addEventListener('loadedmetadata', res, {once:true});
    });
    try { await v.play(); } catch {}
  }

  // ---- НОВЫЙ режим одного снимка с задержкой 10–30 сек ----
  async function runSingle(){
    title.textContent = 'Режим подхода — 1 снимок';
    pill.textContent  = 'Подготовка камеры';
    setStatus('Дай доступ к камере. Снимок будет сделан автоматически.');
    progress(0);
    stopBtn.classList.remove('hidden');

    await ensureCamera();

    const delaySec = rndInt(delayMin, delayMax);
    const started = Date.now();

    // Прогресс и обратный отсчёт
    while (!stopRequested){
      const elapsed = Math.floor((Date.now() - started)/1000);
      const left = Math.max(0, delaySec - elapsed);
      pill.textContent = (left > 0) ? `Снимок через ${left} сек` : 'Снимок…';
      progress(Math.min(100, Math.round(elapsed / delaySec * 100)));
      if (elapsed >= delaySec) break;
      await sleep(300);
    }
    if (stopRequested) return;

    setStatus('Отправляю…');
    await captureAndSend('single');
    progress(100);
    pill.textContent = 'Готово';
    setStatus('Фото отправлено');
    endAndClose(350);
  }

  // Старый режим с несколькими снимками (если shots>1)
  async function runWorkout(){
    title.textContent = 'Режим тренировки';
    pill.textContent  = `${shots} случайных снимка`;
    setStatus('Камера активна. Оставь окно открытым.');
    progress(0);
    stopBtn.classList.remove('hidden');

    await ensureCamera();

    const schedule = randomSchedule(shots, windowSec);
    const startedAt = Date.now();
    let made = 0;

    const timer = setInterval(()=>{
      const elapsed = (Date.now()-startedAt)/1000;
      const p = Math.min(100, Math.round(elapsed/windowSec*100));
      progress(p);
    }, 500);

    try{
      for (const tSec of schedule){
        if (stopRequested) break;
        const waitMs = Math.max(0, tSec*1000 - (Date.now()-startedAt));
        await sleep(waitMs);
        if (stopRequested) break;

        try{
          await captureAndSend('workout');
          made += 1;
          pill.textContent = `Снимок ${made}/${shots}`;
          setStatus('Отправлено');
        }catch(e){
          console.error(e);
          setStatus(`Ошибка: ${e?.message||e}`, true);
        }
      }
    } finally {
      clearInterval(timer);
      progress(100);
      pill.textContent = 'Готово';
      setStatus('Сеанс завершён');
      endAndClose(500);
    }
  }

  async function run(){
    try{
      // Если shots>1 — множественные снимки; иначе — одиночный с задержкой
      if (mode === 'workout' && shots > 1) await runWorkout();
      else await runSingle();
    }catch(e){
      console.error(e);
      setStatus('Ошибка камеры/загрузки: ' + (e?.message||e), true);
      endAndClose(600);
    }
  }

  window.addEventListener('beforeunload', () => { stopStream(); });
  run();
})();
</script>
</body>
</html>
